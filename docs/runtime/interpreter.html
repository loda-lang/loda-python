<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>loda.runtime.interpreter API documentation</title>
<meta name="description" content="Evaluate programs." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>loda.runtime.interpreter</code></h1>
</header>
<section id="section-intro">
<p>Evaluate programs.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-

&#34;&#34;&#34;Evaluate programs.&#34;&#34;&#34;

from loda.lang import Operand, Operation, Program
from loda.oeis import ProgramCache
from .operations import exec_arithmetic


class Interpreter:

    def __init__(self,
                 program_cache: ProgramCache = None,
                 max_steps: int = -1,
                 max_memory: int = -1,
                 max_loop_stack_size: int = 100,
                 max_terms_cache_size: int = 10000):
        &#34;&#34;&#34;
        The interpreter class is used to run LODA programs. Running programs operate on memory dictionaries
        mapping indices to integer values. The most common use case it to evaluate programs to integer sequences.

        Args:
            program_cache: Program cache (optional). When referencing programs using OEIS sequence IDs,
                the program cache must be supplied.
            max_steps: Maximum number of executions steps (-1 for no limit).
            max_loop_stack_size: Maximum stack size used for loops (-1 for no limit).
            max_terms_cache_size: Maximum cache size for sequence terms (-1 for no limit).

        ## Example
        &gt;&gt;&gt; # Evaluate a program to an integer sequence:
        &gt;&gt;&gt; fibonacci = Program(...)
        &gt;&gt;&gt; interpreter.eval_to_seq(fibonacci, num_terms=10)
        ([0, 1, 1, 2, 3, 5, 8, 13, 21, 34], 305)

        &#34;&#34;&#34;
        self.__program_cache = program_cache
        self.__max_steps = max_steps
        self.__max_memory = max_memory
        self.__max_loop_stack_size = max_loop_stack_size
        self.__max_terms_cache_size = max_terms_cache_size
        self.__terms_cache = {}
        self.__running_programs = set()

    def clear_cache(self):
        &#34;&#34;&#34;Clear the program and the terms cache. This is useful to free accumulated memory.&#34;&#34;&#34;
        if self.__program_cache:
            self.__program_cache.clear()
        self.__terms_cache.clear()

    def eval_to_seq(self, program: Program, num_terms: int, use_steps=False):
        &#34;&#34;&#34;
        Evaluate a program to an integer sequence.

        Args:
            program: The program to be evaluated.
            num_terms: The number of sequence terms to be computed.
            use_steps: Flag indicating whether to return the number of steps as sequence.
        Return:
            This function returns a pair. The first entry is the computed integer sequence
            as a list of ints. The second entry is the number of used computation steps.
        &#34;&#34;&#34;
        seq = []
        mem = {}
        total_steps = 0
        for i in range(num_terms):
            mem.clear()
            mem[0] = i
            steps = self.run(program, mem)
            seq.append(steps if use_steps else mem[0])
            total_steps += steps
        return seq, total_steps

    def run(self, id_or_program, memory: dict):
        &#34;&#34;&#34;Run a program.&#34;&#34;&#34;
        if isinstance(id_or_program, Program):
            return self.__run(id_or_program, memory)
        elif isinstance(id_or_program, int):
            id = id_or_program
            if id in self.__running_programs:
                self.__raise(&#34;recursion detected&#34;)
            if self.__program_cache is None:
                self.__raise(&#34;program cache not set&#34;)
            program = self.__program_cache.get(id)
            if program is None:
                self.__raise(&#34;program not found: {}&#34;.format(id))
            self.__running_programs.add(id)
            steps = 0
            try:
                steps = self.__run(program, memory)
            finally:
                self.__running_programs.remove(id)
            return steps
        else:
            self.__raise(
                &#34;expected ID or program: {}&#34;.format(id_or_program))

    def __run(self, p: Program, mem: dict) -&gt; int:

        # remove nop operations
        ops = list(
            filter(lambda op: (op.type != Operation.Type.NOP), p.operations))

        # check for loops with fragments
        if any(op.type == Operation.Type.LPB and op.source != Operand(Operand.Type.CONSTANT, 1) for op in ops):
            self.__raise(&#34;unsupported operation: {}&#34;.format(op))

        # check for empty program
        if len(ops) == 0:
            return 0

        # define stacks
        loop_stack = []
        counter_stack = []
        mem_stack = []

        steps = 0
        num_ops = len(ops)
        mem_tmp = mem.copy()
        mem_seq = {}

        # start program execution
        pc = 0
        while pc &lt; num_ops:
            op = ops[pc]
            pc_next = pc + 1

            if op.type == Operation.Type.LPB:
                if len(loop_stack) &gt;= self.__max_loop_stack_size and self.__max_loop_stack_size &gt;= 0:
                    self.__raise(
                        &#34;maximum stack size exceeded: {}&#34;.format(len(loop_stack)))
                loop_stack.append(pc)
                mem_stack.append(mem_tmp.copy())
                counter = self.__get(op.target, mem_tmp, False)
                counter_stack.append(counter)

            elif op.type == Operation.Type.LPE:
                lpb = ops[loop_stack[-1]]
                counter = self.__get(lpb.target, mem_tmp, False)
                if counter &gt;= 0 and counter &lt; counter_stack[-1]:
                    pc_next = loop_stack[-1] + 1  # jump back to begin
                    mem_stack[-1] = mem_tmp.copy()
                    counter_stack[-1] = counter
                else:
                    mem_tmp = mem_stack.pop()
                    loop_stack.pop()
                    counter_stack.pop()

            elif op.type == Operation.Type.SEQ:
                argument = self.__get(op.target, mem_tmp)
                seq_id = self.__get(op.source, mem_tmp)
                key = (seq_id, argument)
                if key in self.__terms_cache:
                    seq_result, seq_steps = self.__terms_cache[key]
                else:
                    mem_seq.clear()
                    mem_seq[0] = argument
                    seq_steps = self.run(seq_id, mem_seq)
                    seq_result = mem_seq.get(0, 0)
                    if self.__max_terms_cache_size &lt; 0 or len(self.__terms_cache) &lt;= self.__max_terms_cache_size:
                        self.__terms_cache[key] = (seq_result, seq_steps)
                self.__set(op.target, seq_result, mem_tmp, op)
                steps += seq_steps

            else:
                # arithmetic operation
                target = self.__get(op.target, mem_tmp)
                source = self.__get(op.source, mem_tmp)
                self.__set(op.target, exec_arithmetic(
                    op.type, target, source), mem_tmp, op)

            pc = pc_next

            # count execution steps
            steps += 1

            # check resource constraints
            if steps &gt; self.__max_steps and self.__max_steps &gt;= 0:
                self.__raise(&#34;exceeded maximum number of steps ({}); last operation: {}&#34;.format(
                    self.__max_steps, op))
            if len(mem_tmp) &gt; self.__max_memory and self.__max_memory &gt;= 0:
                self.__raise(
                    &#34;exceeded maximum memory: {}; last operation: {} &#34;.format(len(mem_tmp), op))

        # sanity check
        if len(loop_stack) + len(counter_stack) + len(mem_stack) &gt; 0:
            self.__raise(&#34;execution error&#34;)

        # update main memory and return steps
        mem.clear()
        mem.update(mem_tmp)
        return steps

    def __get(self, op: Operand, mem, get_address=False):
        if op.type == Operand.Type.CONSTANT:
            if get_address:
                self.__raise(&#34;cannot get address of a constant&#34;)
            return op.value
        elif op.type == Operand.Type.DIRECT:
            return op.value if get_address else mem.get(op.value, 0)
        elif op.type == Operand.Type.INDIRECT:
            return mem.get(op.value, 0) if get_address else mem.get(mem.get(op.value, 0), 0)

    def __set(self, op: Operand, v, mem, last):
        index = op.value
        if op.type == Operand.Type.CONSTANT:
            self.__raise(&#34;cannot set value of a constant&#34;)
        elif op.type == Operand.Type.INDIRECT:
            index = mem.get(index, 0)
        if index &gt; self.__max_memory and self.__max_memory &gt;= 0:
            self.__raise(
                &#34;maximum memory exceeded: {}; last operation: {}&#34;.format(index, last))
        if v == None:
            self.__raise(
                &#34;overflow in {}; last operation: {}&#34;.format(op, last))
        mem[index] = v

    def __raise(msg: str) -&gt; None:
        raise ValueError(msg)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="loda.runtime.interpreter.Interpreter"><code class="flex name class">
<span>class <span class="ident">Interpreter</span></span>
<span>(</span><span>program_cache: <a title="loda.oeis.program_cache.ProgramCache" href="../oeis/program_cache.html#loda.oeis.program_cache.ProgramCache">ProgramCache</a> = None, max_steps: int = -1, max_memory: int = -1, max_loop_stack_size: int = 100, max_terms_cache_size: int = 10000)</span>
</code></dt>
<dd>
<div class="desc"><p>The interpreter class is used to run LODA programs. Running programs operate on memory dictionaries
mapping indices to integer values. The most common use case it to evaluate programs to integer sequences.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>program_cache</code></strong></dt>
<dd>Program cache (optional). When referencing programs using OEIS sequence IDs,
the program cache must be supplied.</dd>
<dt><strong><code>max_steps</code></strong></dt>
<dd>Maximum number of executions steps (-1 for no limit).</dd>
<dt><strong><code>max_loop_stack_size</code></strong></dt>
<dd>Maximum stack size used for loops (-1 for no limit).</dd>
<dt><strong><code>max_terms_cache_size</code></strong></dt>
<dd>Maximum cache size for sequence terms (-1 for no limit).</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Evaluate a program to an integer sequence:
&gt;&gt;&gt; fibonacci = Program(...)
&gt;&gt;&gt; interpreter.eval_to_seq(fibonacci, num_terms=10)
([0, 1, 1, 2, 3, 5, 8, 13, 21, 34], 305)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Interpreter:

    def __init__(self,
                 program_cache: ProgramCache = None,
                 max_steps: int = -1,
                 max_memory: int = -1,
                 max_loop_stack_size: int = 100,
                 max_terms_cache_size: int = 10000):
        &#34;&#34;&#34;
        The interpreter class is used to run LODA programs. Running programs operate on memory dictionaries
        mapping indices to integer values. The most common use case it to evaluate programs to integer sequences.

        Args:
            program_cache: Program cache (optional). When referencing programs using OEIS sequence IDs,
                the program cache must be supplied.
            max_steps: Maximum number of executions steps (-1 for no limit).
            max_loop_stack_size: Maximum stack size used for loops (-1 for no limit).
            max_terms_cache_size: Maximum cache size for sequence terms (-1 for no limit).

        ## Example
        &gt;&gt;&gt; # Evaluate a program to an integer sequence:
        &gt;&gt;&gt; fibonacci = Program(...)
        &gt;&gt;&gt; interpreter.eval_to_seq(fibonacci, num_terms=10)
        ([0, 1, 1, 2, 3, 5, 8, 13, 21, 34], 305)

        &#34;&#34;&#34;
        self.__program_cache = program_cache
        self.__max_steps = max_steps
        self.__max_memory = max_memory
        self.__max_loop_stack_size = max_loop_stack_size
        self.__max_terms_cache_size = max_terms_cache_size
        self.__terms_cache = {}
        self.__running_programs = set()

    def clear_cache(self):
        &#34;&#34;&#34;Clear the program and the terms cache. This is useful to free accumulated memory.&#34;&#34;&#34;
        if self.__program_cache:
            self.__program_cache.clear()
        self.__terms_cache.clear()

    def eval_to_seq(self, program: Program, num_terms: int, use_steps=False):
        &#34;&#34;&#34;
        Evaluate a program to an integer sequence.

        Args:
            program: The program to be evaluated.
            num_terms: The number of sequence terms to be computed.
            use_steps: Flag indicating whether to return the number of steps as sequence.
        Return:
            This function returns a pair. The first entry is the computed integer sequence
            as a list of ints. The second entry is the number of used computation steps.
        &#34;&#34;&#34;
        seq = []
        mem = {}
        total_steps = 0
        for i in range(num_terms):
            mem.clear()
            mem[0] = i
            steps = self.run(program, mem)
            seq.append(steps if use_steps else mem[0])
            total_steps += steps
        return seq, total_steps

    def run(self, id_or_program, memory: dict):
        &#34;&#34;&#34;Run a program.&#34;&#34;&#34;
        if isinstance(id_or_program, Program):
            return self.__run(id_or_program, memory)
        elif isinstance(id_or_program, int):
            id = id_or_program
            if id in self.__running_programs:
                self.__raise(&#34;recursion detected&#34;)
            if self.__program_cache is None:
                self.__raise(&#34;program cache not set&#34;)
            program = self.__program_cache.get(id)
            if program is None:
                self.__raise(&#34;program not found: {}&#34;.format(id))
            self.__running_programs.add(id)
            steps = 0
            try:
                steps = self.__run(program, memory)
            finally:
                self.__running_programs.remove(id)
            return steps
        else:
            self.__raise(
                &#34;expected ID or program: {}&#34;.format(id_or_program))

    def __run(self, p: Program, mem: dict) -&gt; int:

        # remove nop operations
        ops = list(
            filter(lambda op: (op.type != Operation.Type.NOP), p.operations))

        # check for loops with fragments
        if any(op.type == Operation.Type.LPB and op.source != Operand(Operand.Type.CONSTANT, 1) for op in ops):
            self.__raise(&#34;unsupported operation: {}&#34;.format(op))

        # check for empty program
        if len(ops) == 0:
            return 0

        # define stacks
        loop_stack = []
        counter_stack = []
        mem_stack = []

        steps = 0
        num_ops = len(ops)
        mem_tmp = mem.copy()
        mem_seq = {}

        # start program execution
        pc = 0
        while pc &lt; num_ops:
            op = ops[pc]
            pc_next = pc + 1

            if op.type == Operation.Type.LPB:
                if len(loop_stack) &gt;= self.__max_loop_stack_size and self.__max_loop_stack_size &gt;= 0:
                    self.__raise(
                        &#34;maximum stack size exceeded: {}&#34;.format(len(loop_stack)))
                loop_stack.append(pc)
                mem_stack.append(mem_tmp.copy())
                counter = self.__get(op.target, mem_tmp, False)
                counter_stack.append(counter)

            elif op.type == Operation.Type.LPE:
                lpb = ops[loop_stack[-1]]
                counter = self.__get(lpb.target, mem_tmp, False)
                if counter &gt;= 0 and counter &lt; counter_stack[-1]:
                    pc_next = loop_stack[-1] + 1  # jump back to begin
                    mem_stack[-1] = mem_tmp.copy()
                    counter_stack[-1] = counter
                else:
                    mem_tmp = mem_stack.pop()
                    loop_stack.pop()
                    counter_stack.pop()

            elif op.type == Operation.Type.SEQ:
                argument = self.__get(op.target, mem_tmp)
                seq_id = self.__get(op.source, mem_tmp)
                key = (seq_id, argument)
                if key in self.__terms_cache:
                    seq_result, seq_steps = self.__terms_cache[key]
                else:
                    mem_seq.clear()
                    mem_seq[0] = argument
                    seq_steps = self.run(seq_id, mem_seq)
                    seq_result = mem_seq.get(0, 0)
                    if self.__max_terms_cache_size &lt; 0 or len(self.__terms_cache) &lt;= self.__max_terms_cache_size:
                        self.__terms_cache[key] = (seq_result, seq_steps)
                self.__set(op.target, seq_result, mem_tmp, op)
                steps += seq_steps

            else:
                # arithmetic operation
                target = self.__get(op.target, mem_tmp)
                source = self.__get(op.source, mem_tmp)
                self.__set(op.target, exec_arithmetic(
                    op.type, target, source), mem_tmp, op)

            pc = pc_next

            # count execution steps
            steps += 1

            # check resource constraints
            if steps &gt; self.__max_steps and self.__max_steps &gt;= 0:
                self.__raise(&#34;exceeded maximum number of steps ({}); last operation: {}&#34;.format(
                    self.__max_steps, op))
            if len(mem_tmp) &gt; self.__max_memory and self.__max_memory &gt;= 0:
                self.__raise(
                    &#34;exceeded maximum memory: {}; last operation: {} &#34;.format(len(mem_tmp), op))

        # sanity check
        if len(loop_stack) + len(counter_stack) + len(mem_stack) &gt; 0:
            self.__raise(&#34;execution error&#34;)

        # update main memory and return steps
        mem.clear()
        mem.update(mem_tmp)
        return steps

    def __get(self, op: Operand, mem, get_address=False):
        if op.type == Operand.Type.CONSTANT:
            if get_address:
                self.__raise(&#34;cannot get address of a constant&#34;)
            return op.value
        elif op.type == Operand.Type.DIRECT:
            return op.value if get_address else mem.get(op.value, 0)
        elif op.type == Operand.Type.INDIRECT:
            return mem.get(op.value, 0) if get_address else mem.get(mem.get(op.value, 0), 0)

    def __set(self, op: Operand, v, mem, last):
        index = op.value
        if op.type == Operand.Type.CONSTANT:
            self.__raise(&#34;cannot set value of a constant&#34;)
        elif op.type == Operand.Type.INDIRECT:
            index = mem.get(index, 0)
        if index &gt; self.__max_memory and self.__max_memory &gt;= 0:
            self.__raise(
                &#34;maximum memory exceeded: {}; last operation: {}&#34;.format(index, last))
        if v == None:
            self.__raise(
                &#34;overflow in {}; last operation: {}&#34;.format(op, last))
        mem[index] = v

    def __raise(msg: str) -&gt; None:
        raise ValueError(msg)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="loda.runtime.interpreter.Interpreter.clear_cache"><code class="name flex">
<span>def <span class="ident">clear_cache</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clear the program and the terms cache. This is useful to free accumulated memory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_cache(self):
    &#34;&#34;&#34;Clear the program and the terms cache. This is useful to free accumulated memory.&#34;&#34;&#34;
    if self.__program_cache:
        self.__program_cache.clear()
    self.__terms_cache.clear()</code></pre>
</details>
</dd>
<dt id="loda.runtime.interpreter.Interpreter.eval_to_seq"><code class="name flex">
<span>def <span class="ident">eval_to_seq</span></span>(<span>self, program: <a title="loda.lang.program.Program" href="../lang/program.html#loda.lang.program.Program">Program</a>, num_terms: int, use_steps=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Evaluate a program to an integer sequence.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>program</code></strong></dt>
<dd>The program to be evaluated.</dd>
<dt><strong><code>num_terms</code></strong></dt>
<dd>The number of sequence terms to be computed.</dd>
<dt><strong><code>use_steps</code></strong></dt>
<dd>Flag indicating whether to return the number of steps as sequence.</dd>
</dl>
<h2 id="return">Return</h2>
<p>This function returns a pair. The first entry is the computed integer sequence
as a list of ints. The second entry is the number of used computation steps.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eval_to_seq(self, program: Program, num_terms: int, use_steps=False):
    &#34;&#34;&#34;
    Evaluate a program to an integer sequence.

    Args:
        program: The program to be evaluated.
        num_terms: The number of sequence terms to be computed.
        use_steps: Flag indicating whether to return the number of steps as sequence.
    Return:
        This function returns a pair. The first entry is the computed integer sequence
        as a list of ints. The second entry is the number of used computation steps.
    &#34;&#34;&#34;
    seq = []
    mem = {}
    total_steps = 0
    for i in range(num_terms):
        mem.clear()
        mem[0] = i
        steps = self.run(program, mem)
        seq.append(steps if use_steps else mem[0])
        total_steps += steps
    return seq, total_steps</code></pre>
</details>
</dd>
<dt id="loda.runtime.interpreter.Interpreter.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, id_or_program, memory: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Run a program.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self, id_or_program, memory: dict):
    &#34;&#34;&#34;Run a program.&#34;&#34;&#34;
    if isinstance(id_or_program, Program):
        return self.__run(id_or_program, memory)
    elif isinstance(id_or_program, int):
        id = id_or_program
        if id in self.__running_programs:
            self.__raise(&#34;recursion detected&#34;)
        if self.__program_cache is None:
            self.__raise(&#34;program cache not set&#34;)
        program = self.__program_cache.get(id)
        if program is None:
            self.__raise(&#34;program not found: {}&#34;.format(id))
        self.__running_programs.add(id)
        steps = 0
        try:
            steps = self.__run(program, memory)
        finally:
            self.__running_programs.remove(id)
        return steps
    else:
        self.__raise(
            &#34;expected ID or program: {}&#34;.format(id_or_program))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="loda.runtime" href="index.html">loda.runtime</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="loda.runtime.interpreter.Interpreter" href="#loda.runtime.interpreter.Interpreter">Interpreter</a></code></h4>
<ul class="">
<li><code><a title="loda.runtime.interpreter.Interpreter.clear_cache" href="#loda.runtime.interpreter.Interpreter.clear_cache">clear_cache</a></code></li>
<li><code><a title="loda.runtime.interpreter.Interpreter.eval_to_seq" href="#loda.runtime.interpreter.Interpreter.eval_to_seq">eval_to_seq</a></code></li>
<li><code><a title="loda.runtime.interpreter.Interpreter.run" href="#loda.runtime.interpreter.Interpreter.run">run</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>